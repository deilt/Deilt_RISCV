# 处理器低功耗技术概述
## 软件层面低功耗
软件层面的**灵活很高** ， 其发掘低功耗的**效果**比硬件低功耗本身的效果更加显著 。

**合理调用处理器的资源：**
- 仅在关键的场景调用耗能高的硬件，在一般的场景尽可能使用**耗能低的硬件**。
- 在处理器空闲的时刻，尽可能进入**低功耗休眠模式**，以节省功耗。


## 系统层面低功耗
系统层面的低功耗技术可以涉及**板级硬件系统**和**芯片内的soc系统**，其原理基本一致。 以 soc系统为例，常见的低功耗技术如下。
- SOC系统中划分不同的**电源域**，能够支持将SOC中的大部分硬件**关闭电源** 。
- SOC系统中划分不同的**时钟域**，能够支持小部分电路以**低速低功耗**的方式运行 。
- 通过不同的电源域与时钟域的组合，划分出不同的**低功耗模式**。 SOC配备 PMU (Power Management Unit ）控制进入或者退出不同的低功耗模式 。
- 软件可以通过使用 PMU 的功能，在不同的场景下进入和退出不同的低功耗模式 。

## 处理器层面低功耗
**常见低功耗技术如下：**
- 1. 处理器指令集中定义一种**休眠指令**，运行该指令后处理器核便进入休眠状态。
	- 休眠状态可分为**浅度休眠**和**深度休眠**。
		- **浅度休眠**状态往往将处理器核的**整个时钟关闭**，但仍然**保留电源供电**，因此可以节省**动态功耗**，但是**静态漏电**功耗仍然有消耗。
		- **深度休眠**状态不仅**关闭处理器核的时钟**，甚至将**电源也关闭** ，因此可以同时省掉动 态和静态功耗 。
- 2. 处理器核深度休眠断电后，其内部**上下文状态**可以有两种策略进行保存和恢复。
	- **策略一**：在处理器核内部使用具有**低功耗维持**（ Retention ）能力的寄存器或者 SRAM 保存处理器状态，这种寄存器或者 SRAM 在主电源被关闭后可以使用极低的漏电消耗保存处理器的状态 。
	- **策略二** ： 使用**软件的保存恢复**（ Save-and-Restore ）机制，即在断电前将处理器的上 下文状态保存在SOC层面的**电源常开域**（ Power Always-on Domain ）中，待到唤醒恢复供电后，使用软件从电源常开域中读取回来加以恢复。
	- 策略一 的优点是休眠和唤醒的**速度极快**，但是 ASIC 设计的复杂度高：策略二的优点是 实现非常**简单**，但是休眠和唤醒的速度相对较**慢**。
- 4. 在处理器的架构上，可以采用**异构**的方式节省功耗 。


## 单元层面低功耗
模块和单元层面的低功耗技术己经进入了 **IC 设计微架构**的范畴。其常见的技术与Soc系统层面基本一致，只不过是规模更小的版本。
- 1. 一个功能完整的单元往往需要单独配备独立的**时钟门控**（ Clock Gate ），当该模块或 者单元空闲时，可以使用时钟门控将其时钟关闭以节省动态功耗。 
- 2. 某些比较独立和规模较大的模块甚至可以划分独立的**电源域**来支持关闭电源，以进一步节省静态功耗 。


## 寄存器层面低功耗
寄存器层面的低功耗技术己经进入了 **IC 设计编码风格**的范畴，可以从以下 3 个方面减少寄存器层面的功耗。

**（1）时钟门控**
- 目前主流的逻辑综合工具均有从**代码风格**中直接推断出 **ICG** （Integrated Clock Gating ）的能力 。因此只要遵循一定的编码风格， 便能够将一组寄存器的时钟自动推断出 ICG ，以节省动态功耗。
- 在逻辑综合完成后，工具可以生成整个电路的“**时钟门控率** （ Clock Gating Rate ）”。 开发者可以通过此“时钟门控率”数据的高低， 来判断其设计的电路是否被自动推断出了足够 的 ICG 。**好的电路**一般有超过 90% 的“时钟门控率”，否则可能是电路中数据通路较少（ 主要以小位宽寄存器为基础的控制电路为主〉，或者编码风格有问题。

**（2）减少数据通路翻转**（减少动态功耗）
- **示例一**：以处理器的流水线为例，每级流水线通常需要配置一位控制位（ Valid 位） 表示该级流水线是否有有效指令。当指令加载至此级流水线时将 Valid 位设为高，离开此级流水线时将 Valid 位清零 。 但是对于此级流水线的数据通路载体部分（ Payload 部分），只有在指令加载至此级流水线时，向载体（ Payload ）部分的寄存器加载指令信息（通常有数十位），而指令离开此级流水线时，载体部分的寄存器无须清零。 通过此方法能够极大减少数据通路部分的寄存器翻转率 。
- **示例二** ： 以 **FIFO** （当容量较小而使用寄存器作为存储部分）设计为例，虽然理论上可以使用比较简单的数据表项逐次移位的方式，实现 FIFO 的先入先出功能，但是却应该使用 维护读写指针的方式（数据表项寄存器则不用移位）实现先入先出的功能。 因为数据表项逐次移位的方式会造成寄存器的大量翻转 ，相比而言，使用读写指针的方式实现则保持了 表项寄存器中的值静止不动，从而大幅减少动态功耗 ，因此应该优先采用此方法。

**（3）数据通路不复位**
- 与上一点同理，对于数据通路部分的寄存器，甚至可以使用**不带复位信号的寄存器** 。 不带复位信号的寄存器**面积更小**，**时序更优**，**功耗更低**。 譬如对于某些缓冲器 (Buffer）、 FIFO 和 Regfile 的寄存器部分，经常使用不带复位的寄存器。
- 但使用不带复位的寄存器时必须小心谨慎，保证其没有作为任何其他控制信号， 以免造成不定态的传播。在前仿真阶段，必须有完善的不定态捕捉机制发现这些问题， 否则可能造成芯片的严重Bug。


## 锁存器层面低功耗
锁存器相比寄存器面积更小，功耗更低。在某些特定的场合使用可以降低芯片功耗，但是锁存器会给数字 ASIC 流程带来极大困扰，因此应该**谨慎使用** 。

## SRAM层面低功耗
SRAM 在芯片设计中经常使用到，可以从以下3个方面减少 SRAM 的功耗 。

`（1）选择合适的SRAM`
- **单口 SRAM**（Single Port SRAM）
	- 功耗与面积的角度来讲，单口 SRAM **最小**。
- **一读一写 SRAM** (Two-Port Regfile）
	- 功耗与面积的角度来讲，一读 一 写 Regfile 其次。
- **双口 SRAM** (Dual-Port SRAM)
	- 功耗与面积的角度来讲，双口 SRAM **最大**。

SRAM 的**数据宽度**也会影响其**面积**。以同等大小的 SRAM 为例，假设总容量为 16 KB, 如果 SRAM 的数据宽度为 32 位，则深度为 4096 。 如果 SRAM 的数据宽度为 64 位，则深度为 2048 。不同的宽度深度比可能会产生面积迥异的 SRAM ，因此也需要综合权衡。

`（2）尽量减少SRAM读写`
- SRAM 的读写动态功耗相当可观，因此应该尽量减少读写 SRAM 。
- 以处理器取指令为例，由于处理器多数按顺序取指，因此应该尽量一次从 SRAM 中多读回 一些指令，而不是反复多次地读取 SRAM (一 次读一点点指令），从而节省 SRAM 的动态功耗。


`（3）空闲时关闭SRAM`
- 与单元**门控时钟**相同的原理，在空闲时应关闭 SRAM 的时钟，以节省动态功耗 。
- SRAM 的漏电功耗相当可观，因此在省电模式下，可以将 SRAM 的电源关闭，以防止漏电。

## 组合逻辑层面低功耗
``(1)减少面积`
- 通过使用尽量少的组合逻辑面积减少静态功耗。 
- 因此从设计思路和代码风格上，应该尽量将大的数据通路（或者运算单元〉进行**复用**，从而减少面积。另外应该避免使用除法、乘法等大面积的运算单元，尽量将其转化为加减法运算。

``(1)减少翻转率`
- 可以通过逻辑门控的方式，在数据通路上加入一 级 **“与”门**，使没有用到的组合逻辑在空 闲时不翻转，从而达到减少动态功耗 的效果。额外加入一级与门，在时序非常紧张的场合 也许无法接受 ，需要谨慎使用 。
## 工艺层面低功耗
工艺层面的低功耗一般涉及使用特殊的工艺单元库
# RISC-V 架构的低功耗机制
## WFI指令
WFI ( Wait For Interrupt ）指令是 RISC-V 架构定义的专门用于休眠的指令。当处理器执行 到 WFI 指令之后，将会停止执行当前的指令流，进入一种空闲状态。这种空闲状态可以被称为 “休眠”状态，直到处理器接收到**中断**（中断局部开关必须被打开，由 mie 寄存器控制〉，处理器便被唤醒 。 处理器被**唤醒后**，如果中断被全局打开 （mstatus 寄存器的队但域控制），则进入中断异常服务程序开始执行；如果中断被全局关闭，则继续顺序执行之前停止的指令流 。

## 系统层面
![](attachment/lowpower.png)



